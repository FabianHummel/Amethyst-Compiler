\documentclass[12pt]{article}

\usepackage{anyfontsize}
\usepackage{fancyhdr}
\usepackage{xcolor}
\usepackage{lipsum}
\usepackage{titlesec}
\usepackage{lastpage}
\usepackage{setspace}
\usepackage{listings}
\usepackage{courier}
\usepackage{lstautogobble}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,left=2.5cm,right=2.5cm,top=\dimexpr25mm+1.5\baselineskip,bottom=2.0cm,headsep=40pt,includeheadfoot]{geometry}

\definecolor{darkgreen}{HTML}{3C8031}
\definecolor{salmon}{HTML}{1457a3}

\lstdefinelanguage{Amethyst}{
  sensitive = true,
  keywords=[1]{for,if,else,while,var,debug,break,return,continue,record,foreach,execute,setblock,tellraw,give},
  keywordstyle=[1]\color{violet},
  keywords=[2]{>,<,==,+,-,/,*,\%,+=,-=,/=,*=,\%=},
  keywordstyle=[2]\color{red},
  keywords=[3]{function,namespace},
  keywordstyle=[3]\color{salmon},
  keywords=[4]{FUNCTION,FOR,IF,ELSE,WHILE,VAR,DEBUG,BREAK,RETURN,CONTINUE,ADVANCEMENT,PREDICATE,RESOURCE,YIELD},
  keywordstyle=[4]\color{teal},
  keywords=[5]{true,false},
  keywordstyle=[5]\color{red},
  keywords=[6]{string,int,dec,bool,array,object},
  keywordstyle=[6]\color{orange},
  keywords=[7]{align,anchored,as,at,facing,in,on,positioned,rotated,store,summon,if,unless,run},
  keywordstyle=[7]\color{red},
  numbers=left,
  numberstyle=\scriptsize,
  stepnumber=1,
  numbersep=8pt,
  showstringspaces=false,
  breaklines=true,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{gray}\ttfamily\textit,
  stringstyle=\color{darkgreen}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinelanguage{Mcfunction}{
  sensitive = true,
  keywords=[1]{advancement,attribute,ban,ban-ip,banlist,bossbar,clear,clone,damage,data,datapack,debug,defaultgamemode,deop,difficulty,effect,enchant,execute,experience,fill,fillbiome,forceload,function,gamemode,gamerule,give,help,item,jfr,kick,kill,list,locate,loot,me,msg,op,pardon,pardon-ip,particle,perf,place,playsound,publish,random,recipe,reload,return,ride,save-all,save-off,save-on,say,schedule,scoreboard,seed,setblock,setidletimeout,setworldspawn,spawnpoint,spectate,spreadplayers,stop,stopsound,summon,tag,team,teammsg,teleport,tell,tellraw,time,title,tm,tp,trigger,w,weather,whitelist,worldborder,xp},
  keywordstyle=[1]\color{violet},
  keywords=[2]{>,<,==,+,-,/,*,\%,+=,-=,/=,*=,\%=},
  keywordstyle=[2]\color{red},
  keywords=[3]{align,anchored,as,at,facing,in,on,positioned,rotated,store,summon,if,unless,run,append,modify,from,set,merge},
  keywordstyle=[3]\color{salmon},
  keywords=[4]{bossbar,entity,score,storage,biome,block,blocks,data,dimension,function,loaded,predicate,matches},
  keywordstyle=[4]\color{teal},
  keywords=[5]{@a,@e,@r,@p,@s},
  keywordstyle=[5]\color{orange},
  numbers=left,
  numberstyle=\scriptsize,
  stepnumber=1,
  numbersep=8pt,
  showstringspaces=false,
  breaklines=true,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{gray}\ttfamily\textit,
  stringstyle=\color{darkgreen}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
  language={Amethyst},
  aboveskip=30pt,
  firstnumber=1,
  autogobble=true,
  basicstyle=\ttfamily
}

\setlength{\parindent}{0pt}%

\fancypagestyle{plain}{
    \fancyhf{} % Header und Footer lÃ¶schen
    \fancyhead[L]{\large\nouppercase\rightmark}
    \fancyhead[R]{Amethyst}
    \renewcommand{\headrulewidth}{0.4pt} % Remove header line
    \fancyfoot[L]{Fabian Hummel}
    \fancyfoot[R]{Page \thepage{} of \pageref{LastPage}}
}

\author{Fabian Hummel}
\begin{document}
    \begin{titlepage}
        \begin{center}
        
        \fontsize{40}{0}\selectfont\textbf{Documentation}
        
        \vspace{3cm}
        
        \includegraphics[scale=0.5]{./logo.png}
        
        \fontsize{20}{30}\selectfont\uppercase{\textbf{Amethyst}}
        
        \vspace{2cm}
        
        \fontsize{20}{30}\selectfont{Compiled language framework for Minecraft Datapacks and Resourcepacks}
        
        \vfill
        
        \fontsize{15}{0}\selectfont{Fabian Hummel}
        \end{center}
    \end{titlepage}

\onehalfspacing

\clearpage
\setlength{\parskip}{\baselineskip}%
\vspace*{-2.9cm}
{\textbf{\LARGE Preface}}
\vspace*{0.9cm}

Datapacks and Resourcepacks are Minecraft's way of scripting custom logic and content into the game using configuration and script files. Since the very beginning, the Minecraft Function language (MCFunction or MCF in short) has been a very verbose and bloated language with often different ways to achieve the same thing which comes at the cost of a relatively high learning curve.

While the MCF language itself can be considered fairly powerful and extensive, it lacks modern syntax which you would expect from a language of today's standard. Resourcepacks on the other hand are relatively easy to write and understand, but very tedious to maintain because of their nature by requiring dozens of files in a confusing amount of different directories.

Amethyst simplifies these things by abstracting the configuration and logic behind a modern, high-level language specifically designed to seamlessly integrate with the game's mechanics. It includes a built-in preprocessing engine to maintain thousands of lines of code at once, and even optimises your code on the fly as best as it can to gain near-native command execution.


\clearpage
\renewcommand{\contentsname}{\LARGE Table of contents}
\vspace*{-4cm}
\setlength{\parskip}{4pt}
\tableofcontents

\clearpage
\setlength{\parskip}{\baselineskip}%
\pagestyle{plain}
\titleformat{\section}[hang]
{\fontsize{60pt}{60pt}\clearpage\selectfont} % Adjust size of section number
{\makebox(0,15)[l]{\thesection.}} % Huge section number
{80pt}
{\fontsize{30pt}{30pt}\selectfont\bfseries} % Adjust size of section title

\titlespacing{\section}{0pt}{*0}{*15}[20pt]

\section{Introduction}            
    \subsection{Installation}
        Amethyst comes in prebuilt binaries for all major Operating Systems and can be downloaded from the Github repository. Once installed, you can start creating Amethyst projects right away.
    \subsection{Usage}
        \subsubsection{Configuration}
            Projects can be created by creating an \lstinline{amethyst.toml} (main configuration file) and a \lstinline{src/} folder where all the project code will be in. Files end in \lstinline{.amy} endings. All other files will be ignored for compilation (with some exceptions like resources)
            
            \begin{lstlisting}[numbers=none]
                minecraft = "/path/to/.minecraft" # if .minecraft is not at the default location
                
                [datapack]
                name = "playground" # project name (resulting folder name)
                namespace = "playground" # datapack namespace (defaults to the project name)
                description = "Test project for the amethyst compiler" # datapack description
                pack_format = 48 # specific pack format (defaults to the latest)
                output = "New World" # folder name of the world where the datapack will be compiled into
                
                [resourcepack]
                name = "playground"
                namespace = "playground"
                description = "Resources for the test project"
                pack_format = 34
            \end{lstlisting}
            
        \subsubsection{Compilation}
            After the project is configured, the compiler can be either ran once to compile the entire project, or in \textbf{watch mode} to continuously compile the project whenever a source file changes by invoking the compiler with the flag \lstinline{-w} or \lstinline{--watch}.
            
            When the compiler has finished creating the datapack or resourcepack, you can \lstinline{/reload} the datapack in Minecraft or press \lstinline{F3 + T} to reload the resourcepack.
        
        \subsubsection{Building for production}
            The data- and resourcepack can be compiled to a production build (\lstinline{.zip} file) that automatically drops all \lstinline{debug} statements / comments and minifies the output code to the bare minimum to gain performance and to reduce the filesize as much as possible. To create a production build, invoke the compiler with the flag \lstinline{-r} or \lstinline{--release}.
        
    \subsection{Quick feature tour}
        \subsubsection{Datatypes and Type safety}
            In Amethyst, variables are statically typed, with some exceptions to dynamic data structures like dynamic arrays. Thankfully, types are inferred most of the time, so you don't have to worry remembering the types everytime.
            
            \begin{lstlisting}
                var x = 5; # x will be of type integer
                x = "Hello"; # error: wrong assignment
            \end{lstlisting}
            
            \begin{lstlisting}
                var y: string; # ok, type is defined at declaration
                y = "Amethyst Shard";
            \end{lstlisting}
            
            \begin{lstlisting}
                var x; # error: type cannot be inferred
            \end{lstlisting}
                
            \begin{enumerate}[label=\arabic*.,ref=\arabic*]
                \item \textbf{Strings} \lstinline{string} \lstinline{"MyString"}
                \item \textbf{Integers} \lstinline{int} \lstinline{1537879} - Integers do not have decimal precisions and range from \textbf{-2.147.483.648} to \textbf{2.147.483.647}.
                \item \textbf{Decimals} \lstinline{dec} \lstinline{8294.245} - Decimals have a 3-digit precision due to scoreboards being unable to store decimal numbers and therefore only range from \textbf{-2.147.483}\textcolor{gray}{,648} to \textbf{2.147.483}\textcolor{gray}{,647}.
                \item \textbf{Booleans} \lstinline{bool} \lstinline{true}, \lstinline{false}
                \item \textbf{Typed Arrays} \lstinline{<type>[]} - Arrays with a fixed type can only contain elements of that exact type.
                \item \textbf{Dynamic Arrays} \lstinline{array} - Arrays that can contain any elements of any datatype. Keep in mind that working with values inside such arrays have limited functionality. See \textit{\hyperref[datatypes_dynamic_arrays]{Dynamic Arrays}} for detailed explanation.
                \item \textbf{Typed Objects} \lstinline|<type>{}| - Objects that hold key-value pairs of elements with a fixed datatype. Keys are always strings.
                \item \textbf{Dynamic Objects} \lstinline{object} - Objects that hold key-value pairs of any data type. Keys are always strings. Note that working with values inside such objects have limited functionality. See \textit{\hyperref[datatypes_dynamic_objects]{Dynamic Objects}} for detailed explanation.
            \end{enumerate}

            
        \subsubsection{Functions}
            All functions defined in Amethyst are essentially normal function as you'd expect them from normal MCF code, with some little extras.
            \begin{lstlisting}
                function my_function(message: string) {
                    debug message;
                }
                
                [on_initialize]
                function init() {
                    my_function("Hello Minecraft World!")
                }
            \end{lstlisting}
            
            We can conclude that functions have parameters that can be used to pass values to different parts of the logic.
            
            Also note the \lstinline{[on_initialize]} attribute. This marks the function as such to run once at the start of the game. It is simply added to the \lstinline{load.json} and runs after Amethysts own initialization code. Another common attribute is \lstinline{[on_tick]}, which marks a function to run every frame and can even be mixed with \lstinline{[on_initialize]}.
            
            To use functions, same with variables, they need to be in scope\footnote{An area where a specific variable or function can be accessed. The usage of such needs to be either above on the same level as its definition or one of its ancestors.} and called with parenthesis like in most programming languages. Arguments can be passed via a comma-separated list between the parenthesis.
            
            The return value can immediatetly be used to assign a variable or print the result like an ordinary value.
            
        \subsubsection{Namespaces}
            To reduce clutter within the codebase itself, Amethyst uses namespaces to group functions and logic into smaller, hierarchical groups. Create a namespace with \lstinline{namespace <name>}.

            \begin{lstlisting}[title=file\_1.amy]
                namespace outer {
                    function a(): string {
                        return "Hello from outer!";
                    }
                    
                    namespace inner {
                        function b() {
                            debug a(); # Hello from outer!
                        }
                    }
                }
            \end{lstlisting}
            
            Namespaces create a new scope, just like functions, which means that function \lstinline{b()} can call function \lstinline{a()} without needing to prefix it with anything, because the function is defined in an ancestor scope.
            
            If function \lstinline{a()} were to call \lstinline{b()}, it would need to invoke it by using \lstinline{inner::b()}.

            
            Namespaces can also be defined as many times as needed, and even across multiple files. To call function \lstinline{b()} from another file, while still being in namespace \lstinline{outer}, we would again use \lstinline{inner::b()}, because this is where the function is defined relative to namespace \lstinline{outer}.

            \begin{lstlisting}[title=file\_2.amy]
                namespace outer {
                    debug inner::b(); # Hello from outer!
                    
                    # namespace b and function inner() defined in another file!
                }
            \end{lstlisting}
            
            Sibling namespaces however have also access to each other, which means that a top-level namespace \lstinline{outer_sibling} has full access to \lstinline{outer} using \lstinline{outer::<whatever>}
            
            \begin{lstlisting}
                namespace outer_sibling {
                    debug outer::a(); # Hello from outer!
                }
            \end{lstlisting}


        \subsubsection{Selectors}
            Amethyst takes Minecraft's Selectors to a new level by allowing the reuse of Selectors throughout the program, do calculations upon them and mix them with variables to allow for comprehensive logic.
            
            The idea of the @-Sytax with brackets is kept the same, but nicely integrated into the Amethyst language.
            
            \begin{lstlisting}[language=Amethyst]
                record x = 5;
                
                var players = @a[
                    record:x=..10,
                    distance=100..
                ];
                 
                foreach player in players {
                    tellraw player "My score: " + x[player];
                    # or tellraw @s "My score: " + x[@s];
                }
            \end{lstlisting}
            
            Also note the \lstinline{foreach} statement that is used to iterate over the players. In this case, it purely serves as syntactic sugar and is converted internally to the traditional \lstinline[language=Mcfunction]{execute as @a[...] run [...]} command. Usually, \lstinline{foreach} is rather used to iterate over a data source like arrays or objects. More on that in section~\ref{sec:loops}
            
        \subsubsection{Loops} \label{sec:loops}
            Loops can be used to iterate over a number of different data structures like arrays, objects, strings and players. Iteration may happen through many different ways, namely \lstinline{for}, \lstinline{while} and \lstinline{foreach}.
            
            \begin{lstlisting}[title=Iterating over an array of elements with a classic for loop]
                var arr = ["Hello", "Minecraft", "World"];
                for (var i = 0; i < arr.length; i++) {
                    debug arr[i]; # Hello
                }                 # Minecraft 
                                  # World
            \end{lstlisting}
            
            \begin{lstlisting}[title=Iterating over elements of an object with a foreach loop]
                var obj = {"weather":"raining", "humidity":60, "cloudy":true};
                foreach (key, value) in obj {
                    debug key + ": " + value;
                }
            \end{lstlisting}
            
        \subsubsection{Variables and Player-specific data}
            In Minecraft there are two types of variables. On one hand, variables can be allocated to \textit{central data sources}\footnote{These can be global storages or scoreboards. In the case of Amethyst, these would be the \lstinline{amethyst:internal} storage and the \lstinline{amethyst} scoreboard, where all normal variables are stored.}, and are created using the \lstinline{var} keyword. On the other hand, variables can also be bound to players, so each player holds their own value for a specific variable. In Amethyst, these types of variables are called records and can be created using the \lstinline{record} keyword.
            
            When creating a record, keep in mind that the default value will be assigned to each player in the world once, or whenever they \textit{join or leave the game}\footnote{Special events on when to reassign the default value can be configured for a record using the attributes \lstinline{[assign_on_join]} and \lstinline{[assign_on_leave]}. This is useful to reset e.g. points in a minigame whenever a player leaves the game.}. When assigning a record during execution of the program, the value will be set for all players immediately.
            
            \label{first_data_resource} \begin{lstlisting}[title=Increase points for a player that kills another player]
                ADVANCEMENT player_killed_player {
                  "criteria": {
                    "requirement": {
                      "trigger": "minecraft:player_killed_entity",
                      "conditions": {
                        "entity": {
                          "type": "minecraft:player"
                        }
                      }
                    }
                  }
                }
            
                record points = 0;
                
                [player_killed_player]
                function handle_player_killed_enemy() {
                    points[@s]++;
                }
            \end{lstlisting}
            
            Note the use of the attribute \lstinline{player_killed_player}, which is an advancement defined earlier that grants a player that has killed another player. This advancement can then be assigned to a function via an attribute, which adds that function to the rewards list and will execute whenever that event triggers.
            
            Also note that the points only increase for the player that has actually killed an enemy using the \lstinline{@s} selector. Records can be combined with a selector to change a value only for the entities matching the selector.
            
        \subsubsection{Basic Commands}
            Thankfully, adapting to Amethyst is fairly easy due to common commands having familiar syntax with MCF.
            
            \paragraph{Execute} The execute command has all the functionality that's expected from this command, with some neat extra features to provide better integration with Amethyst. Things like \textbf{block bodies} or \textbf{functions} can be used after the \lstinline{run} keyword instead of traditionally only one following command. Therefore, syntax like this is possible:
            
                \begin{lstlisting}
                    execute as @a at @s run {
                        setblock ~ ~-1 ~ "diamond_block";
                        tellraw @s + " placed a diamond block!";
                    };
                \end{lstlisting}
                
                 \begin{lstlisting}
                    function give_coin_and_say_thanks(amount: int) {
                        give @s "gold_nugget" amount;
                        tellraw @p[tag="Admin"] @s + " thanked you for " + amount + " coin(s)";
                    }
                    
                    execute as @a run give_coin_and_say_thanks(rand_int(10));
                \end{lstlisting}
                
        \subsubsection{Data Resources}
            As already used earlier in an \textit{\hyperref[first_data_resource]{example snippet}}, Amethyst allows for inline declaration of data resources such as \textbf{Advancements, Predicates, Loot Tables} and much more you would find in any ordinary datapack. The same applies to resourcepacks, where we can declare \textbf{textures, models}, and more right in the Amethyst project.
            
            Resources are declared with uppercase letters "\lstinline{ADVANCEMENT}" or "\lstinline{PREDICATE}" which means they are \textit{compile-time constants} and let you preprocess them however you like to save important time\footnote{In this case, compile-time constants allow the creation a template resource with variables and automatically generate multiple variants of that resource during compilation.}.
            
            With the use of \lstinline{FOR} and \lstinline{YIELD} you can save hours of tedious work of copying files or code over and over again with the risk of making simple mistakes by letting the compiler do the work for you.
            
            \begin{lstlisting}
                [override]
                RESOURCE models/item/carrot_on_a_stick {
                  "parent": "item/generated",
                  "textures": {
                    "layer0": "item/carrot_on_a_stick"
                  },
                  "overrides": YIELD (VAR frame = 0; frame < 20; frame++) {
                    "predicate": { "custom_model_data": frame }, 
                    "model": "item/magic_wand/equip_" + frame 
                  }
                }
            \end{lstlisting}
            
            \begin{lstlisting}
                FOR (VAR variant = 1; variant <= 10; variant++) {
                    [override]
                    RESOURCE "models/block/dirt_" + variant {
                      "parent": "block/cube_all",
                      "textures": {
                        "all": "block/dirt_" + variant
                      }
                    }
                }
            \end{lstlisting}
            
            Traditional resource files (\lstinline{.json} files) can still be placed in the project under the directory where they would normally go in a data- or resourcepack and will be copied to the output directory as usual. However, keep in mind that these files do not support preprocessing natively through Amethyst.
            
            This way, you can even add your own \lstinline{.mcfunction} files to the datapack if you require to keep some functions native or want to include a datapack library.
            
            \begin{lstlisting}
                amethyst.toml
                /src
                |   /data
                |   |   /my_pack
                |   |   |   /loot_tables
                |   |   |   |   /my_loot_table.json
                |   |   /included_library
                |   |   |   /functions
                |   |   |   |   /lib_code.mcfunction
                |   main.amy
            \end{lstlisting}
            
        \subsubsection{Preprocessing}
            Speaking of preprocessing, it's also possible to define compile-time constant functions with the \lstinline{FUNCTION} keyword. It works like a regular function, but is evaluated during compile-time and is mostly used to generate boilerplate code.
            
            Additionally, the preprocessing engine allows for more complex control flow with \lstinline{IF}, \lstinline{ELSE} and loops (\lstinline{FOR}, \lstinline{WHILE} and \lstinline{YIELD}).
            
            However, note that variables used within preprocessing need to be declared as compile-time as well with an uppercase \lstinline{VAR}. This is in order to distinguish runtime variables from compile-time ones. 
            
        \subsubsection{Debugging}
            Currently, Amethyst does not yet feature a way of dynamically debugging a program (Although I do have plans for that using a vscode-extension), but can still be done using the \lstinline{debug} keyword that logs a message to all players on the server (therefore should not be used in production).
            
            Furthermore, the debug keyword also syntax-highlights datatypes such as objects, arrays and numbers and make debugging a little easier on the eyes (at the cost of performance).
            
            \begin{lstlisting}
                var x = 10;
                debug x; # [DEBUG]: 10
            \end{lstlisting}
   
\section{Examples}
	\subsection{Fibonacci Sequence}
		The fibonacci sequence is a classic example to demonstrate different aspects and capabilities of a programming language. Therefore, this algorithm can be used to show off basic syntax of a language and get a first impression. In the case of Amethyst, it does not use any special features that have anything to do with Minecraft, but is still a good example for recursion and mathematical expressions.
		
		\begin{lstlisting}
		    function fibonacci(n: int): int {
		        if (n < 2) { return n; }
		        return fibonacci(n - 1) + fibonacci(n - 2);
		    }
		    
		    for (var i = 0; i < 10; i++) {
		        debug fibonacci(i); # 0 1 1 2 3 5 8 13 ...
		    }
		\end{lstlisting}

\section{Reference}
    \subsection{Datatypes}
        Some type of values are stored in scoreboards, while others are better suited for storages.
        \begin{enumerate}[label=\arabic*.,ref=\arabic*]
            \item \textbf{Strings} \lstinline{"MyString"} are stored in storages as normal strings.
            \item \textbf{Integers} \lstinline{1537879} are stored natively in scoreboards.
            \item \textbf{Decimals} \lstinline{8294.245} are stored with 100x scale in scoreboards (to preserve decimal precision).
            \item \textbf{Booleans} \lstinline{true, false} are stored as 0 or 1 inside scoreboards. Altough storages support boolean values natively, it's easier and faster to do calculations with 0 and 1 like toggling between true and false with a single command.
            \item \label{datatypes_dynamic_arrays} \textbf{Dynamic Arrays} \lstinline{[]} are stored in storages with special formatting as Minecraft does not support dynamic arrays out of the box. This means that every array element is wrapped in an object with a special accessor. The following array \lstinline|[10,true,"Hello",[],{}]| is stored with this NBT: \lstinline|[{_:10},{_:true},{_:"Hello"},{_:[]},{_:{}}]| and can be used like any ordinary array with an index and the special accessor: \lstinline{my_array[2]._ # "Hello"}
            \item \textbf{Typed Arrays} \lstinline{[]} are stored as usual arrays in storages natively.
            \item \label{datatypes_dynamic_objects} \textbf{Dynamic Objects} \lstinline|{}| are stored in storages with special formatting similar to dynamic arrays because the entries cannot be accessed via index, unlike arrays. This means that all keys of the object are indexed inside a wrapper object in an iterable array. The following object \lstinline|{test:10,hello:"World",arr:[2,3,4]}| is stored with this NBT: \lstinline|{_keys:["test","hello","arr"],_data:{test:10,hello:"World",arr:[2,3,4]}}| and can be iterated by iterating over the \lstinline{_keys} array and retrieving the actual value of the object using a macro: \lstinline{obj._data.$(_key)}.
            \item \textbf{Typed Objects} \lstinline|{}| are stored in the exact same way as dynamic objects, but enforce a strict type policy for the object's values to ensure type safety when accessing values.
        \end{enumerate}
        
    \subsection{Code Transpilation}
        \paragraph{Conditions:}
            In order to evaluate conditions, we simply have to make sure we early return, if the evaluation is false:
            
            \begin{lstlisting}[language=Mcfunction]
                # condition evaluation (whatever is necessary to calculate)
                execute if score _out amethyst matches 0 run return fail
            \end{lstlisting}
        
        \paragraph{Branching:}
            Logical control flow is handled in a special way to allow for branching with \lstinline{if} and \lstinline{else} - something that is hardly possible in regular MCF.
            
            \begin{lstlisting}[language=Amethyst,title=Language Reference]
                if (age >= 12) {
                    # do some stuff
                } else {
                    debug "Must be at least 12 years old"
                }
            \end{lstlisting}
            
            \begin{lstlisting}[language=Mcfunction,title=calling.mcfunction]
                execute if function if_func run return 1
                execute if score _brk amethyst matches 1 run return fail
                execute if score _ctn amethyst matches 1 run return fail
            \end{lstlisting}
              
            \begin{lstlisting}[language=Mcfunction,title=if.mcfunction]
                # evaluate condition
                # evaluate if branch
                execute if score _out amethyst matches 1 run return run function then_branch
                # evaluate else branch
                return run function else_branch
            \end{lstlisting}
    
        \paragraph{Loops:}
            In MCF, loops can always defined through while true loops with a breaking condition. This means that all types of loops (for, while, ...) can be rewritten to the form of a while-true loop.
            
            \begin{lstlisting}[language=Amethyst,title=Language Reference]
                for (var x=0; x<10; x++) {
                    # do some stuff
                }
            \end{lstlisting}
            
            \begin{lstlisting}[language=Mcfunction,title=calling.mcfunction]
                execute if function loop run return 1
            \end{lstlisting}
              
            \begin{lstlisting}[language=Mcfunction,title=loop.mcfunction]
                # evaluate condition
                # evaluate body
                execute if score _brk amethyst matches 1 run return fail
                scoreboard players set _ctn amethyst 0
                function loop
            \end{lstlisting}
            
        \paragraph{Callable Functions:}
            Normally, functions in MCF can only be called without parameters. Amethyst adds this functionality by pushing arguments onto a stack.
            
            \begin{lstlisting}[language=Amethyst,title=Language Reference]
                function my_func(arg1, arg2, arg3) {
                    debug arg1 + ", " + arg2 + ", " + arg3;
                }
               
                [on_initialize] 
                function main() {
                    my_func("Hello World", 10, {x: true}); # Hello World, 10, {x: true}
                }
            \end{lstlisting}
        
            \begin{lstlisting}[language=Mcfunction,title=calling.mcfunction]
                # foreach all parameters:
                # evaluate parameter
                data modify storage amethyst:internal _argv append from storage amethyst:internal _out
                
                function my_func
                
                # for _ in 0..parameter_count
                data remove storage amethyst:internal _argv[0]
            \end{lstlisting}
            
            \begin{lstlisting}[language=Mcfunction,title=my\_func.mcfunction]
                # do some stuff and use parameters with _argv[-<n+1>]
            \end{lstlisting}
            
    \subsection{More on Control Flow}
        As maybe already noticed, Amethyst internally heavily relies on the \lstinline{return} command to control the logical flow through the program. However, the following concepts have to be kept in mind to understand what's actually happening:
        \begin{enumerate}
            \item \lstinline[language=Amethyst]{return} is used to completely return to a functions entry point, including breaking out of every \lstinline{if, for} or whatsoever. This call is denoted in the source code using the MCF equivalent \lstinline[language=Mcfunction]{return 1} which basically returns from the current function with a successful value 1.
                
            \item \lstinline[language=Amethyst]{break} is used to only escape the current control flow like \lstinline{for} or \lstinline{while}-loops. To distinguish this behaviour from the full return, \lstinline[language=Mcfunction]{return fail} is used instead with an additional \lstinline{_brk} flag that is set to 1.

            \item \lstinline[language=Amethyst]{continue} is used to escape the current control flow up until the first loop by passing \lstinline[language=Mcfunction]{return fail} up the call-tree with an additional \lstinline{_ctn} flag that is set to 1. In the loop, the \lstinline{_ctn} flag will be acknowledged, reset to 0, and continues execution like usual.
        \end{enumerate}
            
        The intended behaviour can be best explained by looking at the actual generated datapack code for the following Amethyst code:
        \begin{lstlisting}[language=Amethyst]
            for (var x = 0; x < 10; x = x+1) {
                if (x > 5) {
                    return; # or break or continue (check the difference);
                }
            }
        \end{lstlisting}
\end{document}
